<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Zumi.io - Evolu√ß√£o</title>
<style>

html,body{
  margin:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#0b1220;
  font-family:'Segoe UI', Arial, sans-serif;
  touch-action: none;
}

canvas{display:block;}
#overlay, #gameOver {
  position:fixed; inset:0; background:rgba(0,0,0,0.85);
  color:white; display:flex; justify-content:center;
  align-items:center; flex-direction:column;
  z-index:10; text-align:center; padding: 20px;
}
#gameOver { display: none; background: rgba(139, 0, 0, 0.9); }
#instructions{
  background: rgba(255,255,255,0.1);
  padding: 20px;
  border-radius: 12px;
  margin: 20px 0;
  font-size: 16px;
  line-height: 1.6;
  max-width: 400px;
}
h1{ font-size: 64px; margin: 0; color: #2ecc71; text-shadow: 0 4px 10px rgba(0,0,0,0.5); }
button{
  padding: 15px 40px; font-size: 24px; cursor: pointer;
  border: none; border-radius: 50px;
  background: #2ecc71; color: white;
  transition: transform 0.2s;
}
button:hover{ transform: scale(1.1); background: #27ae60; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="overlay">
  <h1>Zumi.io</h1>
  <div id="instructions">
    ‚Ä¢ Noite com Visibilidade Melhorada<br>
    ‚Ä¢ Efeitos de √Ågua ao Nadar<br>
    ‚Ä¢ Montanhas Ampliadas em 50%<br>
    ‚Ä¢ Ciclo de Dia (2 min) e Noite (1 min)
  </div>
  <button id="startBtn">Come√ßar Explora√ß√£o</button>
</div>

<div id="gameOver">
  <h1 style="color:#ff4d4d; font-size:72px;">GAME OVER</h1>
  <p style="font-size: 24px;">Voc√™ sucumbiu √† natureza.</p>
  <button onclick="location.reload()">Reiniciar</button>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
function getTouchPos(touch){
  const rect = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

// ===== MOBILE CONTROLS =====
let touchMove = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };
let touchAim  = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };
let touchAttack = false;
let joystick = {
  radius: 55,
  knobRadius: 22
};

// === CONTROLES MOBILE 100% FUNCIONAIS ===
if(isMobile){
  canvas.addEventListener("touchstart", e=>{
  e.preventDefault();
  for(const t of e.changedTouches){

    const pos = getTouchPos(t);

    // JOYSTICK ‚Äî lado esquerdo
    if(pos.x < canvas.width / 2 && !touchMove.active){

      touchMove.active = true;
      touchMove.id = t.identifier;

      touchMove.startX = Math.max(
        joystick.radius + 10,
        Math.min(canvas.width - joystick.radius - 10, pos.x)
      );

      touchMove.startY = Math.max(
        canvas.height * 0.6,
        Math.min(canvas.height - joystick.radius - 10, pos.y)
      );

      touchMove.dx = 0;
      touchMove.dy = 0;
    }

    // MIRA / ATAQUE ‚Äî lado direito
    else if(pos.x >= canvas.width / 2 && !touchAim.active){

      touchAim.active = true;
      touchAim.id = t.identifier;

      touchAim.startX = pos.x;
      touchAim.startY = pos.y;

      touchAim.dx = 0;
      touchAim.dy = 0;
    }

  }
}, {passive:false});

  canvas.addEventListener("touchmove", e=>{
  e.preventDefault();

  for(const t of e.changedTouches){

    if(t.identifier === touchMove.id){
      const pos = getTouchPos(t);
      touchMove.dx = pos.x - touchMove.startX;
      touchMove.dy = pos.y - touchMove.startY;
    }

    if(t.identifier === touchAim.id){
      const pos = getTouchPos(t);
      touchAim.dx = pos.x - touchAim.startX;
      touchAim.dy = pos.y - touchAim.startY;
    }

  }
}, {passive:false});

  canvas.addEventListener("touchend", e => {
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier === touchAim.id){
      if(!player.attacking) touchAttack = true; // dispara ataque mesmo sem mover
      touchAim.active = false;
      touchAim.dx = 0;
      touchAim.dy = 0;
      touchAim.id = null;
    }
  }
});
}
const GAME_WIDTH = 1280;
const GAME_HEIGHT = 720;

function resize(){
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;

  if(!isMobile){
    // PC ‚Üí tela cheia, sem barras
    canvas.width = screenW;
    canvas.height = screenH;

    canvas.style.width = "100vw";
    canvas.style.height = "100vh";
    canvas.style.position = "fixed";
    canvas.style.left = "0";
    canvas.style.top = "0";
    canvas.style.transform = "none";
  } else {
    // MOBILE ‚Üí proporcional (como j√° era)
    const scale = Math.min(
      screenW / GAME_WIDTH,
      screenH / GAME_HEIGHT
    );

    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    canvas.style.width = (GAME_WIDTH * scale) + "px";
    canvas.style.height = (GAME_HEIGHT * scale) + "px";

    canvas.style.position = "absolute";
    canvas.style.left = "50%";
    canvas.style.top = "50%";
    canvas.style.transform = "translate(-50%, -50%)";
  }

  document.body.style.background = "#000";
}


resize();
window.addEventListener("resize", resize);
 // chama ao iniciar

const MAP=20000;
const SAND_COLOR = "#e3d3a3";
const SAND_WIDTH = 300;
const MOUNTAIN_COLOR = "#4a4a4a";
const SAFE_SPAWN_DIST = 1200;
const ZOMBIE_SPREAD_DIST = 150;

// CONFIGURA√á√ïES
const DAY_DURATION = 360 * 60;
const NIGHT_DURATION = 240 * 60; 
const BERRY_RESPAWN_TIME = 60 * 60;
const ORE_RESPAWN_TIME = 120 * 60;
const TREE_RESPAWN_TIME = 120 * 60;
let zombieSpawnTimer = 0;
let worldTime = 0;
let isDay = true;
let isBloodMoon = false;
let bloodMoonTimer = 0;

const BLOOD_MOON_DURATION = 480 * 60; // 8 minutos
const BLOOD_MOON_CHANCE = 0.10; // 10%
let dayCount = 1;

const stars = [];
for(let i=0;i<400;i++){
  stars.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, s: Math.random()*2, a: Math.random()*0.8});
}
const player={
  x:MAP/2, y:MAP/2-2500, r:20,
  speed:4, hp:100, maxHp:100,
  angle:0, hidden:false,
  attacking:false, atkTimer:0,
  weapon:0, hitTimer:0,
  attackProgress:0,
  stamina:100, maxStamina:100, exhausted: false,
  food: 100, maxFood: 100,
  foodCooldown: 0,
  wood:0, stone:0, gold:0, sticks:0,
  dead: false
};
let craftingOpen = false;
let ultimoTickGlobal = Date.now();
const recipes = {
  axe: {
    name: "Machado",
    wood: 3,
    stone: 1,
    weaponIndex: 1
  },
  pickaxe: {
    name: "Picareta",
    wood: 2,
    stone: 3,
    weaponIndex: 2
  }
};
const weapons = [
  {
    name: "M√£o",
    range: 30,
    damage: 5,
    speed: 12,
    style: "hand"
  },
  {
    name: "Machado",
    range: 42,
    damage: 20,
    speed: 16,
    style: "axe"
  },
  {
    name: "Picareta",
    range: 46,
    damage: 22,
    speed: 18,
    style: "pickaxe"
  }
];

let bushes=[], trees=[], rocks=[], particles=[], mountains=[], rivers=[], zombies=[], resources=[], animals=[], rabbitHoles=[];

function makeRock(x, y, radius, color, type="stone") {
  const points = [];
  const n = 6 + Math.floor(Math.random() * 5);
  for (let i = 0; i < n; i++) {
    const angle = (Math.PI * 2 / n) * i;
    const rad = radius * (0.7 + Math.random() * 0.6);
    points.push({x: Math.cos(angle) * rad, y: Math.sin(angle) * rad});
  }
  return {x, y, r:radius, color, points, type, hp: 100, active: true, respawnTimer: 0};
}
// üîß MODELO PADR√ÉO DE RECURSO (UNIFICA√á√ÉO BASE)
function createResource(type, x, y, r){
  return {
    type,      // "tree", "stone", "gold", "stick"
    x, y,
    r,         // raio da hitbox
    hp: 1,
    alive: true
  };
}
function spawnZombie(type = "normal") {
  let x, y;
  let attempts = 0;

  do {
    x = Math.random() * MAP;
    y = Math.random() * MAP;
    attempts++;
    if (attempts > 50) return;
  } while (
    Math.hypot(x - player.x, y - player.y) < SAFE_SPAWN_DIST ||
    zombies.some(z => Math.hypot(x - z.x, y - z.y) < ZOMBIE_SPREAD_DIST)
  );

  if(type === "blood"){
    zombies.push({
      x, y,
      r: 66,
      hp: 300,
      speed: 0.6,
      active: true,
      type: "blood"
    });
  } else {
    zombies.push({
      x, y,
      r: 22,
      hp: isBloodMoon ? 200 : 100,
      speed: isBloodMoon ? 1.8 : 1.2,
      active: true,
      type: "normal"
    });
  }
}
function drawRock(rock, offsetX=0, offsetY=0, scale=1){
  if(!rock.active) return;
  ctx.save();
  if(rock.type === "gold") {
    let glow = Math.sin(Date.now()/300) * 5;
    ctx.shadowBlur = 10 + glow;
    ctx.shadowColor = "#FFD700";
  }
  ctx.fillStyle = rock.color;
  ctx.beginPath();
  rock.points.forEach((p,i)=>{
    const px = (rock.x + p.x) * scale - offsetX;
    const py = (rock.y + p.y) * scale - offsetY;
    if(i===0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  });
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

rivers.push({type: "rect", x:0, y:MAP/2-300, w:MAP, h:600, color:"#3498db"});
const circularRiver = {type: "circle", x: MAP/2, y: MAP/2, r: 1500, color: "#3498db"};

function isInRiver(x,y){
  if(x > rivers[0].x && x < rivers[0].x+rivers[0].w && y > rivers[0].y && y < rivers[0].y+rivers[0].h) return true;
  if(Math.hypot(x-circularRiver.x, y-circularRiver.y) < circularRiver.r) return true;
  return false;
}

function isInSand(x,y){
  if(isInRiver(x,y)) return false; 
  if(y > (rivers[0].y - SAND_WIDTH) && y < (rivers[0].y + rivers[0].h + SAND_WIDTH)) return true;
  const dist = Math.hypot(x-circularRiver.x, y-circularRiver.y);
  if(dist < circularRiver.r + SAND_WIDTH) return true;
  return false;
}

// MONTANHAS AMPLIADAS EM 50% (1250 -> 1875)
const M_RADIUS = 1875;
const mPos=[{x:M_RADIUS, y:M_RADIUS}, {x:MAP-M_RADIUS, y:M_RADIUS}, {x:M_RADIUS, y:MAP-M_RADIUS}, {x:MAP-M_RADIUS, y:MAP-M_RADIUS}];
mPos.forEach(pos=>{
  const m = {x:pos.x, y:pos.y, r:M_RADIUS, color:MOUNTAIN_COLOR, goldRocks:[], stoneRocks:[]};
  for(let i=0;i<25;i++){
  const a = Math.random() * Math.PI * 2;
const d = m.r * (0.4 + Math.random() * 0.5); // MAIS ESPALHADO
m.goldRocks.push(
  makeRock(
    m.x + Math.cos(a) * d,
    m.y + Math.sin(a) * d,
    25,
    "#FFD700",
    "gold"
  )
);

const a2 = Math.random() * Math.PI * 2;
const d2 = m.r * (0.4 + Math.random() * 0.5);
m.stoneRocks.push(
  makeRock(
    m.x + Math.cos(a2) * d2,
    m.y + Math.sin(a2) * d2,
    30,
    "#7f8c8d",
    "stone"
  )
);

  }
  mountains.push(m);
});
// ===== UNIFICA√á√ÉO 3 ‚Äî ETAPA 1 =====
// espelha pedra e ouro das montanhas em resources[]
mountains.forEach(m => {
  m.goldRocks.forEach(r => {
    resources.push({
  type: "gold",
  x: r.x,
  y: r.y,
  r: r.r,
  hp: 160,        // ‚õèÔ∏è ouro mais duro
  maxHp: 160,
  alive: true,
  ref: r
});
  });

  m.stoneRocks.forEach(r => {
    resources.push({
  type: "stone",
  x: r.x,
  y: r.y,
  r: r.r,
  hp: 100,        // ü™® pedra m√©dia
  maxHp: 100,
  alive: true,
  ref: r
});
  });
});
// === SISTEMA DE NASCIMENTO ALEAT√ìRIO SEGURO ===
function findSafeSpawn() {
  let spawnX, spawnY;
  let safe = false;
  let attempts = 0;

  while (!safe && attempts < 100) {
    attempts++;
    spawnX = Math.random() * MAP;
    spawnY = Math.random() * MAP;

    // Verifica se N√ÉO est√° na √°gua, N√ÉO est√° na areia e N√ÉO est√° dentro de montanhas
    const inRiver = isInRiver(spawnX, spawnY);
    const inSand = isInSand(spawnX, spawnY);
    const inMountain = mountains.some(m => Math.hypot(spawnX - m.x, spawnY - m.y) < m.r + 60);

    if (!inRiver && !inSand && !inMountain) {
      safe = true;
    }
  }
  return { x: spawnX, y: spawnY };
}

// Executa a busca pela posi√ß√£o e aplica ao player
const startPos = findSafeSpawn();
player.x = startPos.x;
player.y = startPos.y;

for(let i=0;i<10000;i++){
  let x=Math.random()*MAP, y=Math.random()*MAP;
  let inMountain = mountains.some(m => Math.hypot(x-m.x, y-m.y) < m.r);
  let tooClose =
  resources.some(r =>
    r.type === "tree" &&
    Math.hypot(x - r.x, y - r.y) < 160
  ) ||
  bushes.some(b =>
    Math.hypot(x - b.x, y - b.y) < 140
  );
  if(!isInRiver(x,y) && !isInSand(x,y) && !inMountain && !tooClose) {
  if(Math.random() < 0.525) {
    const isLarge = Math.random() > 0.7; 
    resources.push({
      type: "tree",
      x, y,
      r: isLarge ? 75 : 54,
      color: isLarge ? "#1b5e20" : "#2ecc71", 
      hp: isLarge ? 300 : 100, // 300 HP = 15 hits do machado
      maxHp: isLarge ? 300 : 100,
      yield: isLarge ? 3 : 1,
      alive: true
    });
} else {
    // Agora decidimos na cria√ß√£o se ele √â ou N√ÉO um arbusto de fruta
    const isFrutifero = Math.random() < 0.5; 
    bushes.push({
      x, y, r: 40, 
      isBerryBush: isFrutifero, // Identidade fixa
      hasFruit: isFrutifero, 
      respawnTimer: 0
    });
}
 }
}
// üåø SPAWN INICIAL DE GRAVETOS (Vers√£o Ajustada)
for(let i = 0; i < 600; i++){ // Aumentei de 600 para 1200 (2x mais)
  let x = Math.random() * MAP;
  let y = Math.random() * MAP;

  // Checa se est√° em lugar proibido
  let inMountain = mountains.some(m => Math.hypot(x-m.x, y-m.y) < m.r);
  let inWater = isInRiver(x,y) || isInSand(x,y);
  
  // Evita APENAS ficar dentro de √°rvores (dist√¢ncia curta de 40)
  let inTree = resources.some(r => r.type === "tree" && Math.hypot(x - r.x, y - r.y) < 80);

  if(!inWater && !inMountain && !inTree){
    resources.push({
      type: "stick",
      x: x, y: y,
      r: 10,
      alive: true,
      respawnTimer: 0
    });
  }
}
const keys={},mouse={x:0,y:0,down:false};
onkeydown = e => {
  const k = e.key.toLowerCase();
  keys[k] = true;

  if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
    keys.shift = true;
  }

  // ABRIR / FECHAR INVENT√ÅRIO
  if(k === "c"){
    craftingOpen = !craftingOpen;
  }

  // TROCA DE FERRAMENTA VIA TECLA
  if(k === "1") player.weapon = 0;
  if(k === "2") player.weapon = 1;
  if(k === "3") player.weapon = 2;
};

onkeyup = e => {
  const k = e.key.toLowerCase();
  keys[k] = false;

  if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
    keys.shift = false;
  }
};
window.addEventListener("blur", () => {
  for (let k in keys) keys[k] = false;
});


if(!isMobile){
  onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; }
  onmousedown = () => mouse.down = true;
  onmouseup = () => mouse.down = false;
}

const camX=()=>player.x-canvas.width/2;
const camY=()=>player.y-canvas.height/2;

function createParticles(x,y,color,count=6, speedMult=1){
  for(let i=0;i<count;i++){
    const angle=Math.random()*Math.PI*2;
    const speed=(Math.random()*3+1) * speedMult;
    if(particles.length < 800)
    particles.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,r:Math.random()*3+2,life:20+Math.random()*10,color});
  }
}

canvas.addEventListener("click", e => {
  if(!craftingOpen) return;

  const x = e.clientX;
  const y = e.clientY;

  const cx = canvas.width / 2 - 150;
  const cy = canvas.height / 2 - 80;

  // Machado
  if(x > cx && x < cx + 300 && y > cy && y < cy + 40){
    tryCraft("axe");
  }

  // Picareta
  if(x > cx && x < cx + 300 && y > cy + 50 && y < cy + 90){
    tryCraft("pickaxe");
  }
});
canvas.addEventListener("mousedown", e => {
  if(craftingOpen) return;

  const mx = e.clientX;
  const my = e.clientY;

  inventorySlots.forEach(slot => {
    if(
      mx >= slot.x &&
      mx <= slot.x + slot.w &&
      my >= slot.y &&
      my <= slot.y + slot.h
    ){
      // slots de ferramentas
      if(slot.index === 3) player.weapon = 1; // machado
      if(slot.index === 4) player.weapon = 2; // picareta
      if(slot.index === 5) player.weapon = 0; // m√£o
    }
  });
});

function tryCraft(type){
  const r = recipes[type];

  if(player.wood < r.wood) return;
  if(player.stone < r.stone) return;

  player.wood -= r.wood;
  player.stone -= r.stone;

  player.weapon = r.weaponIndex;
}
function spawnAnimal() {
  let pos = findSafeSpawn();

  if(!pos || pos.x === undefined) {
      pos = { x: Math.random() * MAP, y: Math.random() * MAP };
  }

  animals.push({
    x: pos.x,
    y: pos.y,
    r: 15, 
    color: "#8d6e63",
    angle: Math.random() * Math.PI * 2,
    timer: 0
  });
}

animals = []; 
for(let i = 0; i < 20; i++) {
    spawnAnimal();
}

console.log("Coelhos criados: " + animals.length);
for(let i = 0; i < 20; i++) spawnAnimal();
function update(){
const agora = Date.now();
    let passouUmSegundo = false;

    if (agora - ultimoTickGlobal >= 1000) {
        passouUmSegundo = true;
        ultimoTickGlobal = agora;
    }

    if (player.dead) {
        player.attacking = false;
        player.attackProgress = 0;
        return;
    }

    if (craftingOpen) return;
    
if(!isDay && dayCount >= 3){
  // ‚è±Ô∏è S√≥ aumenta o timer UMA vez por segundo real
  if(passouUmSegundo) {
    zombieSpawnTimer++;
  }

  // 120 segundos = 2 minutos reais
  if(zombieSpawnTimer >= 120){ 
    for(let i = 0; i < 10; i++){
      spawnZombie("normal");
    }

    if(isBloodMoon){
      for(let i = 0; i < 3; i++){
        spawnZombie("blood");
      }
    }

    zombieSpawnTimer = 0; // Reseta para a pr√≥xima horda
  }
}
zombies.forEach(z => {
  if(!z.active) return;

  const dx = player.x - z.x;
  const dy = player.y - z.y;
  const dist = Math.hypot(dx, dy) || 1;

  z.x += (dx / dist) * z.speed;
  z.y += (dy / dist) * z.speed;
});
zombies.forEach(z => {
  if(!z.active) return;

  const dist = Math.hypot(player.x - z.x, player.y - z.y);
  if(dist < player.r + z.r){
    player.hp -= 0.2; // dano cont√≠nuo
  }
});
  worldTime++;
 if(isDay && worldTime >= DAY_DURATION){
  isDay = false;
  worldTime = 0;

  // üåï chance de Lua de Sangue ap√≥s a 5¬™ noite
  if(dayCount >= 5 && Math.random() < BLOOD_MOON_CHANCE){
    isBloodMoon = true;
    bloodMoonTimer = 0;
  } else {
    isBloodMoon = false;
  }
}
if(isBloodMoon){
  bloodMoonTimer++;

  if(bloodMoonTimer >= BLOOD_MOON_DURATION){
    isBloodMoon = false;
  }
}
else if(!isDay && worldTime >= NIGHT_DURATION) {
  isDay = true;
  worldTime = 0;
  dayCount++;

  // üåÖ amanheceu ‚Üí remove zumbis
  zombies.length = 0;
  zombieSpawnTimer = 0;
}
// üåø RESPAWN DE FRUTAS (Baseado em segundos reais)
    bushes.forEach(b => {
        if (b.isBerryBush && !b.hasFruit) {
            if (passouUmSegundo) b.respawnTimer++; // S√≥ aumenta 1 por segundo
            
            if (b.respawnTimer >= 120) { // 2 minutos exatos
                b.hasFruit = true;
                b.respawnTimer = 0;
            }
        }
    });

    // üå≤/‚õèÔ∏è RESPAWN DE RECURSOS (√Årvores, Pedras, Ouro)
    resources.forEach(res => {
        if (!res.alive) {
            if (passouUmSegundo) res.respawnTimer++;

            let tempoNecessario = 120; // 2 min padr√£o
            if (res.type === "gold") tempoNecessario = 180; // 3 min ouro

            if (res.respawnTimer >= tempoNecessario) {
                res.alive = true;
                res.respawnTimer = 0;
                res.hp = res.maxHp || 100; // Reseta o HP
                if (res.ref) res.ref.active = true; // Se for de montanha, reativa
            }
        }
    });
  let inWater = isInRiver(player.x, player.y);
  let isMoving =
  keys.w || keys.s || keys.a || keys.d ||
  (isMobile && touchMove.active);
  // EFEITO DE √ÅGUA AO NADAR
  if(inWater && isMoving && Math.random() < 0.3) {
    createParticles(player.x, player.y, "rgba(255,255,255,0.6)", 1, 0.5);
    createParticles(player.x, player.y, "#a0d8ef", 1, 0.3);
  }

  let isSprinting =
  (!isMobile && keys.shift && !player.exhausted && player.stamina > 0) ||
  (isMobile && touchMove.active && Math.hypot(touchMove.dx, touchMove.dy) > joystick.radius * 0.8
 && !player.exhausted);

  let foodDrain = isSprinting ? 0.03 : 0.02;
  if(player.foodCooldown > 0){
  player.foodCooldown--;
} else {
  player.food -= foodDrain;
}
if (player.stamina <= 0) {
  player.stamina = 0;
  player.exhausted = true;
}

if (player.exhausted && player.stamina >= player.maxStamina - 0.1) {
  player.stamina = player.maxStamina;
  player.exhausted = false;
}
  // üçó FOME ‚Üí DANO OU REGENERA√á√ÉO

// dano por fome (2x mais lento)
if(player.food <= 0){
  player.food = 0;
  player.hp -= 0.075; // antes era 0.15
}

// regenera√ß√£o se estiver bem alimentado
if(player.food > player.maxFood * 0.75 && player.hp < player.maxHp){
  player.hp += 0.04; // regenera√ß√£o lenta
}

  if(player.hp <= 0 && !player.dead) {
  player.hp = 0;
  player.dead = true;
  document.getElementById("gameOver").style.display = "flex";
}
// === CONTROLE DE STAMINA (AP√ìS UPDATE) ===
if (player.stamina <= 0) {
  player.stamina = 0;
  player.exhausted = true;
}

if (player.exhausted && player.stamina >= player.maxStamina - 0.1) {
  player.stamina = player.maxStamina;
  player.exhausted = false;
}

  if(isSprinting) player.stamina -= 0.8;
  else if(player.stamina < player.maxStamina) player.stamina = Math.min(player.stamina + 0.4, player.maxStamina);

 let moveSpeed = isSprinting ? player.speed*1.8 : player.speed;
  if(inWater) moveSpeed /= 2;

  if(keys.w) player.y-=moveSpeed;
  if(keys.s) player.y+=moveSpeed;
  if(keys.a) player.x-=moveSpeed;
  if(keys.d) player.x+=moveSpeed;
if(isMobile && touchMove.active){
  const len = Math.hypot(touchMove.dx, touchMove.dy) || 1;
  const nx = touchMove.dx / len;
  const ny = touchMove.dy / len;
  const speedFactor = Math.min(len / joystick.radius, 1);
player.x += nx * moveSpeed * speedFactor;
player.y += ny * moveSpeed * speedFactor;
}

  player.x = Math.max(player.r, Math.min(MAP - player.r, player.x));
  player.y = Math.max(player.r, Math.min(MAP - player.r, player.y));
// üå≥ COLIS√ÉO COM √ÅRVORES (resources[])
resources.forEach(res => {
  if(!res.alive) return;
  if(res.type !== "tree") return;

  const dx = player.x - res.x;
  const dy = player.y - res.y;
  const dist = Math.hypot(dx, dy);

  if(dist < player.r + res.r){
    const angle = Math.atan2(dy, dx);
    const overlap = (player.r + res.r) - dist;
    player.x += Math.cos(angle) * overlap;
    player.y += Math.sin(angle) * overlap;
  }
});
// COLIS√ÉO COM PEDRA E OURO (UNIFICA√á√ÉO 3 ‚Äî ETAPA 2)
resources.forEach(res => {
  if(!res.alive) return;
  if(res.type !== "stone" && res.type !== "gold") return;

  const dx = player.x - res.x;
  const dy = player.y - res.y;
  const dist = Math.hypot(dx, dy);

  if(dist < player.r + res.r){
    const angle = Math.atan2(dy, dx);
    const overlap = (player.r + res.r) - dist;
    player.x += Math.cos(angle) * overlap;
    player.y += Math.sin(angle) * overlap;
  }
});

resources.forEach(res => {
  if(!res.alive) return;

  if(res.type === "stick"){
    if(Math.hypot(player.x - res.x, player.y - res.y) < player.r + res.r){
      res.alive = false;      // "Mata" o item para ele sumir e iniciar o respawn
      res.respawnTimer = 0;   // Reseta o contador de tempo para renascer
      player.sticks += 1;     // Adiciona ao seu invent√°rio de gravetos
      
      // Efeito visual de madeira ao coletar
      if(typeof createParticles === "function") {
        createParticles(res.x, res.y, "#8b5a2b", 4, 0.5);
      }
    }
  }
});
 if(isMobile){
  if(touchAim.active && Math.hypot(touchAim.dx, touchAim.dy) > 5){
  player.angle = Math.atan2(touchAim.dy, touchAim.dx);
}

  // se n√£o estiver mirando, mant√©m o √∫ltimo √¢ngulo (n√£o faz nada)
}
else{
  player.angle = Math.atan2(
    mouse.y - canvas.height/2,
    mouse.x - canvas.width/2
  );
}

  player.hidden=false;
  bushes.forEach(b=>{ if(Math.hypot(player.x-b.x,player.y-b.y)<b.r*1.1) player.hidden=true; });

  if (
  (!isMobile && mouse.down && !player.attacking) ||
  (isMobile && touchAttack && !player.attacking)
) {
  touchAttack = false;
  player.attacking = true;
  player.atkTimer = weapons[player.weapon].speed;
  player.attackProgress = 1;
const w = weapons[player.weapon];
const hx = player.x + Math.cos(player.angle) * w.range;
const hy = player.y + Math.sin(player.angle) * w.range;

bushes.forEach(b => {
  if (b.hasFruit && Math.hypot(hx - b.x, hy - b.y) < b.r + 20) {
    b.hasFruit = false;
    player.food = Math.min(player.maxFood, player.food + 20);
player.foodCooldown = 180; // 3 segundos sem perder fome
    createParticles(hx, hy, "#ff4d4d", 8);
  }
});


// üå≤ CORTE DE √ÅRVORE
resources.forEach(res => {
  if(!res.alive) return;
  if(res.type !== "tree") return;

  if(Math.hypot(hx - res.x, hy - res.y) < res.r + 15){

    // s√≥ machado corta
    if(weapons[player.weapon].style !== "axe") return;

    res.hp -= weapons[player.weapon].damage;
    createParticles(hx, hy, "#2ecc71", 6);

if(res.hp <= 0){
  res.alive = false;
  player.wood += (res.yield || 1); // Ganha 1 se for pequena, 3 se for grande
}
  }
});
// ‚õèÔ∏è ATAQUE EM PEDRA / OURO (UNIFICADO)
resources.forEach(res => {
  if(!res.alive) return;
  if(res.type !== "stone" && res.type !== "gold") return;

  const dist = Math.hypot(hx - res.x, hy - res.y);
  if(dist > res.r + 15) return;

  // s√≥ picareta minera
  if(weapons[player.weapon].style !== "pickaxe") return;

  res.hp -= weapons[player.weapon].damage;
  createParticles(
  hx,
  hy,
  res.type === "gold" ? "#FFD700" : "#7f8c8d",
  res.type === "gold" ? 10 : 8,
  res.type === "gold" ? 1.4 : 1.1
);

  if(res.hp <= 0){
  res.alive = false;

  if(res.type === "gold") player.gold += 1;
  if(res.type === "stone") player.stone += 1;

  if(res.ref) res.ref.active = false;
}
});

if(player.attacking){
  const hx = player.x + Math.cos(player.angle) * weapons[player.weapon].range;
  const hy = player.y + Math.sin(player.angle) * weapons[player.weapon].range;
  
zombies.forEach(z => {
  if(!z.active) return;

  if(Math.hypot(hx - z.x, hy - z.y) < z.r + 15){
    z.hp -= 20;
    createParticles(hx, hy, "#6aff6a", 6);
    if(z.hp <= 0){
      z.active = false;
    }
  }
});

}
}
  if(player.attacking){ player.atkTimer--; if(player.atkTimer<=0) player.attacking=false; }
  if(player.attackProgress>0){ player.attackProgress-=0.15; if(player.attackProgress<0) player.attackProgress=0; }
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--;
   if(p.life<=0) particles.splice(i,1);
  }// --- IA DOS COELHOS COM ANTI-ENCALHE E TOCAS ---
  animals.forEach(a => {
    const dx = player.x - a.x;
    const dy = player.y - a.y;
    const dist = Math.hypot(dx, dy);

    let currentSpeed = 0;
    let inWaterAnimal = isInRiver(a.x, a.y);

    // 1. MOVIMENTA√á√ÉO
    if (dist < 300) {
        a.angle = Math.atan2(-dy, -dx);
        currentSpeed = player.speed * 1.25;
        if (Math.random() < 0.15) {
            createParticles(a.x, a.y, inWaterAnimal ? "#a0d8ef" : "#d2b48c", 1, 0.3);
        }
    } else {
        if (passouUmSegundo) a.timer--;
        if (a.timer <= 0) {
            a.angle = Math.random() * Math.PI * 2;
            a.timer = 3 + Math.random() * 4;
        }
        currentSpeed = player.speed * 0.90;
    }

    if (inWaterAnimal) currentSpeed /= 2;

    // APLICA MOVIMENTO BASE
    a.x += Math.cos(a.angle) * currentSpeed;
    a.y += Math.sin(a.angle) * currentSpeed;

    // 2. ANTI-ENCALHE (EMPURA O COELHO PARA FORA)
    resources.forEach(res => {
        if (!res.alive || res.type === "stick") return;
        if (res.type === "tree" || res.type === "stone" || res.type === "gold") {
            const rDx = a.x - res.x;
            const rDy = a.y - res.y;
            const rDist = Math.hypot(rDx, rDy);
            const minDist = a.r + res.r + 2; // Margem de seguran√ßa

            if (rDist < minDist) {
                const angle = Math.atan2(rDy, rDx);
                const overlap = minDist - rDist;
                // Empurra ele para fora imediatamente
                a.x += Math.cos(angle) * overlap;
                a.y += Math.sin(angle) * overlap;
                // Faz ele mudar de dire√ß√£o para n√£o insistir no erro
                a.angle = angle + (Math.random() - 0.5);
            }
        }
    });

    // 3. CRIAR TOCA (A cada 2 coelhos, 1 faz um buraco a cada 2 min aprox)
    if (passouUmSegundo && Math.random() < 0.005) { // Chance baixa por segundo
        if (rabbitHoles.length < animals.length / 2) { // Limite de 1 buraco para cada 2 coelhos
            if (!inWaterAnimal) {
                rabbitHoles.push({ x: a.x, y: a.y, r: 12, life: 120 }); // Dura 2 min
            }
        }
    }

    a.x = Math.max(a.r, Math.min(MAP - a.r, a.x));
    a.y = Math.max(a.r, Math.min(MAP - a.r, a.y));
  });

  // Gerenciar tempo das tocas
  if (passouUmSegundo) {
      rabbitHoles.forEach((h, i) => {
          h.life--;
          if (h.life <= 0) rabbitHoles.splice(i, 1);
      });
  }
  }
function drawPlayer(ctxRef, x, y, angle, hidden){
  ctxRef.save();
  ctxRef.translate(x, y); ctxRef.rotate(angle);
  ctxRef.globalAlpha = hidden ? 0.3 : 1;

  // Ferramenta atual e o valor do empurr√£o (off)
  const w = weapons[player.weapon];
  const off = player.attackProgress * 20; // Aumentei para 20 para o golpe aparecer mais

  if(w.style !== "hand") {
    // 1. CABO (Agora com + off no X para ir para frente)
    ctxRef.fillStyle = "#5d4037";
    ctxRef.fillRect(player.r + off, -3, 30, 6);

    if(w.style === "axe") {
      // 2. MACHADO (Agora com + off em todos os pontos X)
      ctxRef.fillStyle = "#bdc3c7";
      ctxRef.beginPath();
      ctxRef.moveTo(player.r + 20 + off, -15);
      ctxRef.lineTo(player.r + 35 + off, -20);
      ctxRef.lineTo(player.r + 35 + off, 20);
      ctxRef.lineTo(player.r + 20 + off, 15);
      ctxRef.fill();
    } 
    else if(w.style === "pickaxe") {
      // 3. PICARETA (Agora com + off no centro do arco)
      ctxRef.strokeStyle = "#7f8c8d";
      ctxRef.lineWidth = 6;
      ctxRef.lineCap = "round";
      ctxRef.beginPath();
      ctxRef.arc(player.r + 15 + off, 0, 20, -Math.PI/2, Math.PI/2);
      ctxRef.stroke();
    }
  }

  // CORPO DO PLAYER
  ctxRef.fillStyle = "#d2b48c"; ctxRef.beginPath(); ctxRef.arc(0, 0, player.r, 0, Math.PI*2); ctxRef.fill();

  // M√ÉOS (Mantendo o movimento que voc√™ j√° tinha)
  const hands = [{x: player.r, y: -14}, {x: player.r, y: 14}];
  hands.forEach(h => {
    ctxRef.save(); 
    ctxRef.translate(h.x + off, h.y);
    ctxRef.fillStyle = "#d2b48c"; 
    ctxRef.beginPath(); 
    ctxRef.arc(0, 0, 7, 0, Math.PI*2); 
    ctxRef.fill();
    ctxRef.restore();
  });
  
  ctxRef.restore();
}
function drawJoystick(){

  if(!isMobile || !touchMove.active) return;

  const baseX = touchMove.startX;
  const baseY = touchMove.startY;
  let dx = touchMove.dx;
  let dy = touchMove.dy;

  // limite do knob
  const dist = Math.hypot(dx, dy);
  if(dist > joystick.radius){
    dx = dx / dist * joystick.radius;
    dy = dy / dist * joystick.radius;
  }

  // base do joystick
  ctx.beginPath();
  ctx.arc(baseX, baseY, joystick.radius, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fill();

  // knob
  ctx.beginPath();
  ctx.arc(baseX + dx, baseY + dy, joystick.knobRadius, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.45)";
  ctx.fill();
}
function drawAimJoystick(){
  if(!isMobile || !touchAim.active) return;

  const baseX = touchAim.startX;
  const baseY = touchAim.startY;
  let dx = touchAim.dx;
  let dy = touchAim.dy;

  const maxDist = 60;
  const dist = Math.hypot(dx, dy);
  if(dist > maxDist){
    dx = dx / dist * maxDist;
    dy = dy / dist * maxDist;
  }

  ctx.beginPath();
  ctx.arc(baseX, baseY, 45, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(baseX + dx, baseY + dy, 18, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.45)";
  ctx.fill();
}
function drawMobileHUD(){
    // barras adapt√°veis
const barWidth = Math.min(160, canvas.width * 0.4);
const barHeight = 8;
const barX = 20;
const barY = 20; // ajuste para mobile se quiser mais baixo
    const x = 20;
    let y = 20;

    ctx.font = `${Math.floor(barHeight*1.2)}px Arial`;
    ctx.textBaseline = "middle";

    // ‚ù§Ô∏è VIDA
    ctx.fillText("‚ù§Ô∏è", x, y);
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.fillRect(x+30, y-7, barWidth, barHeight);
    ctx.fillStyle="#e74c3c";
    ctx.fillRect(x+30, y-7, barWidth*(player.hp/player.maxHp), barHeight);
    y += barHeight + 14;

    // ‚ö° STAMINA
    ctx.fillText("‚ö°", x, y);
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.fillRect(x+30, y-7, barWidth, barHeight);
    ctx.fillStyle=player.exhausted ? "#95a5a6" : "#f1c40f";
    ctx.fillRect(x+30, y-7, barWidth*(player.stamina/player.maxStamina), barHeight);
    y += 30;

    // üçó FOME
    ctx.fillText("üçó", x, y);
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.fillRect(x+30, y-7, barWidth, barHeight);
    ctx.fillStyle="#ff9800";
    ctx.fillRect(x+30, y-7, barWidth*(player.food/player.maxFood), barHeight);
 }   

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#3f8f4d"; ctx.fillRect(-camX(),-camY(),MAP,MAP);

  ctx.fillStyle = SAND_COLOR; 
  ctx.fillRect(rivers[0].x-camX(), rivers[0].y-SAND_WIDTH-camY(), rivers[0].w, rivers[0].h + (SAND_WIDTH*2));
  ctx.beginPath(); ctx.arc(circularRiver.x-camX(), circularRiver.y-camY(), circularRiver.r + SAND_WIDTH, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle=rivers[0].color;
  ctx.fillRect(rivers[0].x-camX(), rivers[0].y-camY(), rivers[0].w, rivers[0].h);
  ctx.beginPath(); ctx.arc(circularRiver.x-camX(), circularRiver.y-camY(), circularRiver.r, 0, Math.PI*2); ctx.fill();
  resources.forEach(res => {
  if(!res.alive) return;

  if(res.type === "stick"){
    ctx.fillStyle = "#8b5a2b";
    ctx.fillRect(
      res.x - 12 - camX(),
      res.y - 3 - camY(),
      24,
      6
    );
  }
});
  mountains.forEach(m=>{
    ctx.fillStyle=m.color; ctx.beginPath(); ctx.arc(m.x-camX(), m.y-camY(), m.r, 0, Math.PI*2); ctx.fill();
    m.goldRocks.forEach(gr=>drawRock(gr, camX(), camY()));
    m.stoneRocks.forEach(sr=>drawRock(sr, camX(), camY()));
    resources.forEach(res => {
  if(!res.alive) return;
  if(res.type !== "stone" && res.type !== "gold") return;

  const hpPct = res.hp / res.maxHp;
  if(hpPct >= 1) return; // s√≥ mostra se sofreu dano

  const barW = 26;
  const barH = 4;
  const x = res.x - barW/2 - camX();
  const y = res.y - res.r - 12 - camY();

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, barW, barH);

  ctx.fillStyle = res.type === "gold" ? "#FFD700" : "#bdc3c7";
  ctx.fillRect(x, y, barW * hpPct, barH);
});
  });
zombies.forEach(z => {
  if(!z.active) return;

  ctx.beginPath();
  ctx.arc(z.x - camX(), z.y - camY(), z.r, 0, Math.PI * 2);

  if(z.type === "blood"){
    ctx.fillStyle = "#b30000";
  } else if(isBloodMoon){
    ctx.fillStyle = "#ff6666";
  } else {
    ctx.fillStyle = "#2ecc71";
  }

  ctx.fill();
});
resources.forEach(res => {
  if(!res.alive) return;

  if(res.type === "tree"){
    // Desenho do tronco e copa (seu c√≥digo original)
    ctx.fillStyle = "#8b5a2b";
    ctx.fillRect(res.x-8-camX(), res.y+10-camY(), 16, 30);
    ctx.fillStyle = res.color;
    ctx.beginPath();
    ctx.arc(res.x-camX(), res.y-camY(), res.r, 0, Math.PI*2);
    ctx.fill();

    // BARRA DE VIDA DA √ÅRVORE (Igual √† da pedra, mas com a cor da √°rvore)
    const hpPct = res.hp / res.maxHp;
    if(hpPct < 1) { // S√≥ mostra se tiver levado dano
      const barW = 40;
      const barH = 6;
      const x = res.x - barW/2 - camX();
      const y = res.y - res.r - 15 - camY();

      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(x, y, barW, barH);

      ctx.fillStyle = res.color; // Usa a mesma cor da copa da √°rvore
      ctx.fillRect(x, y, barW * hpPct, barH);
    }
  }
});
  const viewMargin = 120;
  const all = [
      ...bushes.filter(b => b.x > camX()-viewMargin && b.x < camX()+canvas.width+viewMargin && b.y > camY()-viewMargin && b.y < camY()+canvas.height+viewMargin).map(b=>({...b,t:'b'})),
      ...trees.filter(t => t.active && t.x > camX()-viewMargin && t.x < camX()+canvas.width+viewMargin && t.y > camY()-viewMargin && t.y < camY()+canvas.height+viewMargin).map(t=>({...t,t:'t'})),
      {x:player.x, y:player.y, t:'p'}
  ].sort((a,b)=>a.y-b.y);

  all.forEach(obj => {
    if(obj.t==='b'){
      ctx.fillStyle="#1f7a3a"; ctx.beginPath(); ctx.arc(obj.x-camX(),obj.y-camY(),obj.r,0,Math.PI*2); ctx.fill();
      if(obj.hasFruit) {
          ctx.fillStyle = "#ff4d4d";
          for(let i=0; i<3; i++){ ctx.beginPath(); ctx.arc(obj.x-camX() + Math.cos(i*2)*15, obj.y-camY() + Math.sin(i*2)*15, 6, 0, Math.PI*2); ctx.fill(); }
      }
    } else if(obj.t==='t'){
      ctx.fillStyle="#8b5a2b"; ctx.fillRect(obj.x-8-camX(), obj.y + 10-camY(), 16, 30); 
      ctx.fillStyle=obj.color; ctx.beginPath(); ctx.arc(obj.x-camX(), obj.y-camY(), obj.r, 0, Math.PI*2); ctx.fill();
    } else if(obj.t==='p') drawPlayer(ctx, player.x-camX(), player.y-camY(), player.angle, player.hidden);
  });

  particles.forEach(p=>{ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x-camX(), p.y-camY(), p.r, 0, Math.PI*2); ctx.fill();});
// --- DESENHO DAS TOCAS ---
rabbitHoles.forEach(h => {
    ctx.fillStyle = "#4e342e"; // Marrom bem escuro
    ctx.beginPath();
    ctx.ellipse(h.x - camX(), h.y - camY() + 5, h.r, h.r * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Borda de terra em volta
    ctx.strokeStyle = "#3e2723";
    ctx.lineWidth = 2;
    ctx.stroke();
});
  animals.forEach(a => {
    ctx.save();
    ctx.translate(a.x - camX(), a.y - camY());
    ctx.rotate(a.angle);

    // Corpo (bolinha marrom)
    ctx.fillStyle = "#8d6e63";
    ctx.beginPath();
    ctx.arc(0, 0, a.r, 0, Math.PI * 2);
    ctx.fill();

    // Olhinhos (na frente)
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(a.r * 0.5, -3, 2, 0, Math.PI * 2);
    ctx.arc(a.r * 0.5, 3, 2, 0, Math.PI * 2);
    ctx.fill();

    // Orelhinhas atr√°s
    ctx.fillStyle = "#8d6e63";
    ctx.beginPath();
    // Orelha 1
    ctx.ellipse(-5, -5, 8, 3, 0, 0, Math.PI * 2);
    // Orelha 2
    ctx.ellipse(-5, 5, 8, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
});
  // üåô NOITE ‚Äî JOGADOR MAIS ILUMINADO, BORDAS MAIS ESCURAS
if(!isDay) {
  // estrelas (opcional manter)
  ctx.fillStyle = "white";
 ctx.globalAlpha = 1; // ou 1 se n√£o quiser piscar
stars.forEach(s => {
  ctx.globalAlpha = s.a;
  ctx.fillStyle = "white";
  ctx.fillRect(
  ((s.x - camX()*0.1) + canvas.width) % canvas.width
,
  ((s.y - camY()*0.1) + canvas.height) % canvas.height

,
  s.s, s.s
);
});
ctx.globalAlpha = 1;


  // camada escura forte
  ctx.save();
  ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // recorte de luz no jogador

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  const lightRadius = 800; // luz pr√≥xima
  const fadeRadius  = 1200; // transi√ß√£o

 const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, fadeRadius);
grad.addColorStop(0, "rgba(0,0,0,0)");
grad.addColorStop(0.5, "rgba(0,0,0,0.3)");
grad.addColorStop(1, "rgba(0,0,0,0.85)");

ctx.fillStyle = grad;
ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath();
  ctx.arc(cx, cy, fadeRadius, 0, Math.PI * 2);

  ctx.fill();
  ctx.restore();
  ctx.globalCompositeOperation = "source-over";
}

if(isBloodMoon){
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(
    canvas.width/2 - 180,
    40,
    360,
    60
  );

  ctx.fillStyle = "#ff2a2a";
  ctx.font = "bold 36px Arial";
  ctx.textAlign = "center";
  ctx.fillText(
    "LUA DE SANGUE",
    canvas.width/2,
    82
  );
  ctx.textAlign = "left";
}
  // UI
  if(!player.dead && !isMobile) {
    ctx.fillStyle="#fff"; ctx.font="bold 16px Arial";
    ctx.fillText(`MADEIRA: ${player.wood} | GRAVETOS: ${player.sticks}| PEDRA: ${player.stone} | OURO: ${player.gold}`, 20, 30);
    ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.fillRect(20, 50, 200, 10);
    ctx.fillStyle="#e74c3c"; ctx.fillRect(20, 50, 200*(player.hp/player.maxHp), 10);
    ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.fillRect(20, 65, 200, 10);
    ctx.fillStyle=player.exhausted ? "#95a5a6" : "#f1c40f"; ctx.fillRect(20, 65, 200*(player.stamina/player.maxStamina), 10);
    ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.fillRect(20, 80, 200, 10);
    ctx.fillStyle="#ff9800"; ctx.fillRect(20, 80, 200*(player.food/player.maxFood), 10);
    // MINIMAPA
    const sz=150, p=6, mx=canvas.width-sz-p, my=p, sc=sz/MAP;
    ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.fillRect(mx, my, sz, sz);
    ctx.fillStyle=SAND_COLOR; ctx.beginPath(); 
    ctx.fillRect(mx + rivers[0].x*sc, my + (rivers[0].y-SAND_WIDTH)*sc, rivers[0].w*sc, (rivers[0].h+SAND_WIDTH*2)*sc);
    ctx.arc(mx + circularRiver.x*sc, my + circularRiver.y*sc, (circularRiver.r+SAND_WIDTH)*sc, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle="#3498db"; 
    ctx.fillRect(mx + rivers[0].x*sc, my + rivers[0].y*sc, rivers[0].w*sc, rivers[0].h*sc);
    ctx.beginPath(); ctx.arc(mx + circularRiver.x*sc, my + circularRiver.y*sc, circularRiver.r*sc, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle=MOUNTAIN_COLOR;
    mountains.forEach(m => { ctx.beginPath(); ctx.arc(mx + m.x*sc, my + m.y*sc, m.r*sc, 0, Math.PI*2); ctx.fill(); });
    ctx.fillStyle="#fff";
    ctx.beginPath(); ctx.arc(mx + player.x*sc, my + player.y*sc, 3, 0, Math.PI*2); ctx.fill();
  }
  if(craftingOpen){
  ctx.fillStyle = "rgba(0,0,0,0.75)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = "#fff";
  ctx.font = "bold 28px Arial";
  ctx.textAlign = "center";
  ctx.fillText("CRAFT", canvas.width/2, canvas.height/2 - 120);

  ctx.font = "20px Arial";

  // Caixa Machado
  ctx.fillStyle = "rgba(255,255,255,0.1)";
  ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 80, 300, 40);
  ctx.fillStyle = "#fff";
  ctx.fillText(
    "Machado (3 Madeira, 1 Pedra)",
    canvas.width/2,
    canvas.height/2 - 50
  );

  // Caixa Picareta
  ctx.fillStyle = "rgba(255,255,255,0.1)";
  ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 30, 300, 40);
  ctx.fillStyle = "#fff";
  ctx.fillText(
    "Picareta (2 Madeira, 3 Pedra)",
    canvas.width/2,
    canvas.height/2
  );

  ctx.font = "14px Arial";
  ctx.fillText("Pressione C para fechar", canvas.width/2, canvas.height/2 + 60);

  ctx.textAlign = "left";
}
if(!player.dead && !craftingOpen){
  drawInventory();
}
if(isMobile && !player.dead) drawMobileHUD();
drawJoystick();
drawAimJoystick();

}
function drawInventory(){
  const slotSize = 64;
  const padding = 10;
  const totalSlots = 6;
  const width = totalSlots * (slotSize + padding) - padding;
  const startX = canvas.width/2 - width/2;
  const y = canvas.height - slotSize - 30;

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(startX - 20, y - 20, width + 40, slotSize + 40);

 const items = [
    {name:"Madeira", qty: player.wood},
    {name:"Pedra", qty: player.stone},
    {name:"Ouro", qty: player.gold},
    {name: player.weapon === 1 ? "‚úî" : "", owned: player.weapon === 1}, // Machado
    {name: player.weapon === 2 ? "‚úî" : "", owned: player.weapon === 2}, // Picareta
    {name: player.weapon === 0 ? "‚úî" : "", owned: player.weapon === 0}  // M√£o
  ];

 inventorySlots = [];

items.forEach((item, i)=>{
  const x = startX + i*(slotSize + padding);

  inventorySlots.push({
    x, y,
    w: slotSize,
    h: slotSize,
    index: i
  });

  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y, slotSize, slotSize);

  ctx.strokeStyle = "#fff";
  ctx.lineWidth = player.weapon === i-3 ? 3 : 1;
  ctx.strokeRect(x, y, slotSize, slotSize);

  ctx.fillStyle = "#fff";
  ctx.font = "12px Arial";
  ctx.textAlign = "center";

  if(item.qty !== undefined){
    ctx.fillText(item.qty, x + slotSize/2, y + slotSize - 8);
  }

  ctx.fillText(item.name, x + slotSize/2, y - 6);
});

  ctx.textAlign = "left";
}

let running=false;
function loop(){if(!running) return; update(); draw(); requestAnimationFrame(loop);}
document.getElementById("startBtn").onclick=()=>{document.getElementById("overlay").style.display="none"; running=true; loop();};
</script>
</body>
</html>

